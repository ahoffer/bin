#!/usr/bin/env python3
"""
push â€” push all locally cached images to a target registry

USAGE
  ./push <target-registry> [--source-registry <source-registry>] [--dry-run]

Examples
  ./push bigfish:5000
  ./push bigfish:5000 --source-registry registry.team.local:5000
"""
from __future__ import annotations

import argparse
import json
import shlex
import subprocess
import sys
from typing import Iterable, List


def run(cmd: List[str], check: bool = True, capture: bool = False) -> subprocess.CompletedProcess:
    return subprocess.run(
        cmd,
        check=check,
        text=True,
        stdout=(subprocess.PIPE if capture else None),
        stderr=(subprocess.PIPE if capture else None),
    )


def docker_images_json() -> Iterable[dict]:
    """Yield docker image entries as dicts via JSON-lines format."""
    cp = run(["docker", "images", "--no-trunc", "--format", "{{json .}}"], capture=True)
    for line in cp.stdout.splitlines():
        s = line.strip()
        if not s:
            continue
        try:
            yield json.loads(s)
        except json.JSONDecodeError:
            # Skip malformed row
            continue


def image_exists(ref: str) -> bool:
    """Return True if a local image with the given ref exists."""
    result = subprocess.run(
        ["docker", "image", "inspect", ref],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
    )
    return result.returncode == 0


def main() -> int:
    p = argparse.ArgumentParser(description="Push Docker images to a target registry.")
    p.add_argument("target_registry", help="Target registry to push images to")
    p.add_argument("--source-registry", help="Source registry prefix to retag images from")
    p.add_argument("--dry-run", action="store_true", help="print actions without performing them")
    args = p.parse_args()

    dst = args.target_registry.rstrip("/")
    src = args.source_registry.rstrip("/") if args.source_registry else None

    if src and src == dst:
        print("Source and target registry are the same; nothing to do.")
        return 0

    planned = []
    seen_targets = set()

    for img in docker_images_json():
        repo = img.get("Repository")
        tag = img.get("Tag")
        img_id = img.get("ID")

        # Skip untagged/dangling entries
        if not repo or repo == "<none>" or not tag or tag == "<none>":
            continue

        # If source registry is specified, only process images from that registry
        if src and not repo.startswith(f"{src}/"):
            continue

        if src:
            # Retag images from source registry to target registry
            new_repo = repo.replace(src, dst, 1)
            old_ref = f"{repo}:{tag}"
            new_ref = f"{new_repo}:{tag}"
        else:
            # Default behavior: only push images that already have the target registry prefix
            if not repo.startswith(f"{dst}/"):
                # Skip images that don't already have the target registry prefix
                continue
            
            # Image already has target registry prefix, use as is
            old_ref = f"{repo}:{tag}"
            new_ref = f"{repo}:{tag}"

        if new_ref in seen_targets:
            continue
        seen_targets.add(new_ref)

        planned.append((old_ref, img_id, new_ref))

    if not planned:
        print("No matching images found.")
        return 0

    tagged_n = 0
    pushed_n = 0

    for old_ref, img_id, new_ref in planned:
        if src:
            # Retagging mode: check if target already exists
            exists = image_exists(new_ref)
            if not exists:
                print(f"[TAG ] {old_ref} -> {new_ref}")
                if not args.dry_run:
                    run(["docker", "tag", img_id, new_ref])
                tagged_n += 1
            else:
                print(f"[SKIP] {new_ref} already tagged locally")
        else:
            # Default mode: no retagging, just push
            pass

        print(f"[PUSH] {new_ref}")
        if not args.dry_run:
            run(["docker", "push", new_ref])
        pushed_n += 1

    print(f"Summary: {len(seen_targets)} images processed | {tagged_n} newly tagged | {pushed_n} pushed")
    if args.dry_run:
        print("Dry run complete. Remove --dry-run to execute.")
    return 0


if __name__ == "__main__":
    try:
        sys.exit(main())
    except subprocess.CalledProcessError as e:
        print(f"Command failed: {shlex.join(e.cmd)}\nExit code: {e.returncode}")
        if e.stderr:
            print(e.stderr.strip())
        sys.exit(e.returncode)
