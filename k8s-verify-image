#!/bin/bash
set -euo pipefail

# Verify all pods in a deployment are running the expected image
# Usage: k8s-verify-image [-n namespace] [-r host] [-t timeout] <image:tag> <deployment>
# Examples:
#   k8s-verify-image myapp:1.0 cx-app                    # Verify pods match image
#   k8s-verify-image -n prod myapp:1.0 cx-app            # Specific namespace
#   k8s-verify-image -r node1 -t 120 myapp:1.0 cx-app    # Custom host and timeout

usage() {
  sed -n '4,8p' "$0"
  exit 0
}

namespace="octocx"
remote_host="bigfish"
timeout=60
interval=2
while [[ $# -gt 0 && "$1" == -* ]]; do
  case "$1" in
    -h|--help) usage ;;
    -n|--namespace) namespace="$2"; shift 2 ;;
    -r|--remote) remote_host="$2"; shift 2 ;;
    -t|--timeout) timeout="$2"; shift 2 ;;
    *) echo "Unknown option: $1" >&2; exit 1 ;;
  esac
done

readonly IMAGE="${1:?Usage: k8s-verify-image [-n ns] [-r host] [-t timeout] <image:tag> <deployment>}"
readonly DEPLOY="${2:?Usage: k8s-verify-image [-n ns] [-r host] [-t timeout] <image:tag> <deployment>}"
readonly NAMESPACE="$namespace"
readonly REMOTE_HOST="$remote_host"
readonly RETRY_TIMEOUT="$timeout"
readonly RETRY_INTERVAL="$interval"

get_pod_selector() {
  kubectl get deployment "$DEPLOY" -n "$NAMESPACE" \
    -o jsonpath='{.spec.selector.matchLabels}' |
    jq -r 'to_entries | map("\(.key)=\(.value)") | join(",")'
}

# Check for pod failure states that indicate deployment won't succeed
check_pod_failures() {
  local selector="$1"
  local fatal_reasons="CrashLoopBackOff|ImagePullBackOff|ErrImagePull|CreateContainerConfigError|InvalidImageName"

  while read -r pod_name reason _; do
    [[ -z "$pod_name" ]] && continue
    if [[ "$reason" =~ ^($fatal_reasons)$ ]]; then
      echo "ERROR: Pod $pod_name is in $reason state" >&2
      kubectl describe pod "$pod_name" -n "$NAMESPACE" | tail -20 >&2
      return 1
    fi
  done < <(kubectl get pod -n "$NAMESPACE" -l "$selector" \
    -o jsonpath='{range .items[*]}{.metadata.name} {.status.containerStatuses[0].state.waiting.reason}{"\n"}{end}')

  return 0
}

# Outputs status for each pod, returns 0 if all match expected hash
verify_pod_images() {
  local expected="$1" selector="$2" result=0

  while read -r pod_name pod_hash _; do
    [[ -z "$pod_name" ]] && continue
    if [[ "$pod_hash" == "$expected" ]]; then
      echo "✓ $pod_name"
    else
      printf "✗ %s\n  got:      %s\n  expected: %s\n" "$pod_name" "$pod_hash" "$expected"
      result=1
    fi
  done < <(kubectl get pod -n "$NAMESPACE" -l "$selector" \
    -o jsonpath='{range .items[*]}{.metadata.name} {.status.containerStatuses[0].imageID}{"\n"}{end}')

  return "$result"
}

echo "==> Getting expected image hash from $REMOTE_HOST..."
EXPECTED_HASH=$(ssh "$REMOTE_HOST" "sudo k3s crictl inspecti '$IMAGE' 2>/dev/null" | jq -r '.status.id')
: "${EXPECTED_HASH:?ERROR: Could not get image hash for $IMAGE}"
echo "Expected: $EXPECTED_HASH"

echo "==> Verifying pod images..."
SELECTOR=$(get_pod_selector)
SECONDS=0

while ! output=$(verify_pod_images "$EXPECTED_HASH" "$SELECTOR"); do
  ((SECONDS >= RETRY_TIMEOUT)) && { echo "$output"; echo "ERROR: Image verification failed after ${RETRY_TIMEOUT}s" >&2; exit 1; }
  check_pod_failures "$SELECTOR" || exit 1
  echo "Pods not yet running expected image, retrying in ${RETRY_INTERVAL}s... (${SECONDS}s/${RETRY_TIMEOUT}s)" >&2
  sleep "$RETRY_INTERVAL"
done

echo "$output"
echo "==> All pods verified"
