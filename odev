#!/usr/bin/env bash
set -euo pipefail

# ollama-panel.sh
# Multi-model panel using Ollama /api/chat:
#   generator -> verifier(s) -> reconciler
#
# Designed for concise, correct work across:
# Java 17, OSGi/Karaf, Spring, Solr, Docker, K8s, GitLab CI,
# ActiveMQ, Codice/DDF, Codice/Alliance, Postgres, TypeScript/React.

source "$(dirname "$0")/ollama-lib"

# Comma-separated models.
# First = generator, middle = verifier(s), last = reconciler.
MODELS_CSV="${OLLAMA_MODELS:-qwen3-coder:latest,deepseek-coder:latest,llama3.1:latest}"

TASK="${OLLAMA_TASK:-review}"   # review | create | debug

NUM_PREDICT="${OLLAMA_NUM_PREDICT:-220}"
TEMP_GEN="${OLLAMA_TEMPERATURE_GEN:-0.2}"
TEMP_VERIFY="${OLLAMA_TEMPERATURE_VERIFY:-0.1}"
TEMP_RECONCILE="${OLLAMA_TEMPERATURE_RECONCILE:-0.2}"
TOP_P="${OLLAMA_TOP_P:-0.9}"
REPEAT_PENALTY="${OLLAMA_REPEAT_PENALTY:-1.1}"

STOP_SEQS=(
  "\n\nUser:"
  "\n\nHuman:"
  "\n\nQ:"
  "</final>"
)

DOMAIN_CONTEXT=$'Primary stack / constraints:
- Java 17, Maven, JUnit 5
- OSGi + Apache Karaf (features, bundles, resolver issues, version ranges)
- Spring (Boot 2/3), including non-Boot OSGi containers
- Solr (schema, analysis, queries, performance)
- Docker (multi-stage builds, runtime issues)
- Kubernetes (deployments, Helm), config/secret hygiene
- GitLab CI/CD (.gitlab-ci.yml), runners, caching, artifacts, pipelines, deployments
- ActiveMQ (classic), DLQ patterns
- Codice/DDF, Codice/Alliance conventions
- Postgres (SQL, indexing, jsonb, migrations)
- TypeScript + React + Next.js + Tailwind

Output rules:
- Be concise. Prefer bullets. No preamble.
- Ask at most ONE clarifying question if required (versions, env).
- Otherwise make reasonable assumptions and proceed.
- If code/config is requested: output code only unless asked otherwise.
'

SYSTEM_GEN=$'You are the generator.
Produce the best possible answer for the user request.
Keep it concise and actionable.
If critical version or environment details are missing, ask ONE question and stop.'
$'\n\n'"$DOMAIN_CONTEXT"

SYSTEM_VERIFY=$'You are a verifier.
Critique the generator output for correctness, omissions, and bad assumptions.
Propose concrete fixes.
Bullet points only.
Ask ONE question only if validation is impossible without environment/version info.'
$'\n\n'"$DOMAIN_CONTEXT"

SYSTEM_RECONCILE=$'You are the reconciler.
Merge generator output and verifier feedback into ONE final answer.
Prioritize correctness and brevity.
Include fixes.
Ask ONE question only if unavoidable.'
$'\n\n'"$DOMAIN_CONTEXT"

# If the message references a file path, read and embed its contents.
# Recognizes patterns like "review the file ~/path" or "review ~/path" or
# "debug the file /absolute/path". Expands ~ and caps at 200KB.
embed_file_content() {
  local msg="$1"
  local path=""

  # Match file path after common verbs
  if [[ "$msg" =~ (review|debug|explain|analyze|create)[[:space:]]+(the[[:space:]]+file[[:space:]]+)?([~/][^[:space:]]+) ]]; then
    path="${BASH_REMATCH[3]}"
  fi

  if [[ -z "$path" ]]; then
    printf '%s' "$msg"
    return
  fi

  # Expand leading ~
  path="${path/#\~/$HOME}"

  if [[ ! -f "$path" ]]; then
    printf '%s\n\n(File not found on this host: %s)' "$msg" "$path"
    return
  fi

  local max_bytes=200000
  local actual_bytes
  actual_bytes="$(wc -c < "$path" | tr -d ' ')"
  local content
  if (( actual_bytes > max_bytes )); then
    content="$(head -c "$max_bytes" "$path")"
    printf '%s\n\n--- FILE: %s (truncated to %d bytes) ---\n%s\n--- END FILE ---' \
      "$msg" "$path" "$max_bytes" "$content"
  else
    content="$(cat "$path")"
    printf '%s\n\n--- FILE: %s ---\n%s\n--- END FILE ---' \
      "$msg" "$path" "$content"
  fi
}

split_models() {
  local -a models
  IFS=',' read -ra models <<< "$MODELS_CSV"
  # Trim whitespace from each entry
  local trimmed=()
  for m in "${models[@]}"; do
    m="${m#"${m%%[![:space:]]*}"}"
    m="${m%"${m##*[![:space:]]}"}"
    [[ -n "$m" ]] && trimmed+=("$m")
  done
  if [[ ${#trimmed[@]} -lt 2 ]]; then
    echo "Need at least 2 models (generator, reconciler)." >&2
    return 1
  fi
  printf '%s\n' "${trimmed[@]}"
}

_build_chat_options() {
  local temperature="$1"
  local stop_json
  stop_json=$(printf '%s\n' "${STOP_SEQS[@]}" | jq -R . | jq -sc .)
  jq -n --argjson np "$NUM_PREDICT" --argjson temp "$temperature" \
    --argjson tp "$TOP_P" --argjson rp "$REPEAT_PENALTY" \
    --argjson stop "$stop_json" \
    '{num_predict:$np, temperature:$temp, top_p:$tp, repeat_penalty:$rp, stop:$stop}'
}

print_opts() {
  echo "HOST=$OLLAMA_HOST"
  echo "MODELS=$MODELS_CSV"
  echo "TASK=$TASK"
  echo "NUM_PREDICT=$NUM_PREDICT"
  echo "TEMP_GEN=$TEMP_GEN  TEMP_VERIFY=$TEMP_VERIFY  TEMP_RECONCILE=$TEMP_RECONCILE"
}

panel_run() {
  local user_msg="$1"
  local embedded
  embedded="$(embed_file_content "$user_msg")"

  mapfile -t MODELS < <(split_models)
  local GEN="${MODELS[0]}"
  local REC="${MODELS[-1]}"
  local VERIFIERS=("${MODELS[@]:1:${#MODELS[@]}-2}")

  local gen_out ver_outs reconcile_in final_out

  local gen_opts ver_opts rec_opts
  gen_opts=$(_build_chat_options "$TEMP_GEN")
  ver_opts=$(_build_chat_options "$TEMP_VERIFY")
  rec_opts=$(_build_chat_options "$TEMP_RECONCILE")

  echo "[generator: $GEN]" >&2
  gen_out="$(ollama_chat_simple "$GEN" "$SYSTEM_GEN" "[TASK=$TASK]"$'\n'"$embedded" "odev" "$gen_opts")"

  ver_outs=""
  for v in "${VERIFIERS[@]}"; do
    echo "[verifier: $v]" >&2
    local vo
    vo="$(ollama_chat_simple "$v" "$SYSTEM_VERIFY" "USER REQUEST:"$'\n'"$embedded"$'\n\n'"GENERATOR ANSWER:"$'\n'"$gen_out" "odev" "$ver_opts")"
    ver_outs+=$'\n\n'"[VERIFIER: $v]"$'\n'"$vo"
  done

  reconcile_in="USER REQUEST:
$embedded

GENERATOR:
$gen_out
$ver_outs"

  echo "[reconciler: $REC]" >&2
  final_out="$(ollama_chat_simple "$REC" "$SYSTEM_RECONCILE" "$reconcile_in" "odev" "$rec_opts")"

  echo "$final_out"
}

main() {
  echo "Ollama multi-model panel"
  echo "Models: $MODELS_CSV"
  echo "Commands: /task review|create|debug | /models a,b,c | /opts | /quit"
  echo

  while true; do
    printf "> "
    IFS= read -r line || break
    [[ -z "$line" ]] && continue

    case "$line" in
      /quit) exit 0 ;;
      /opts) print_opts; continue ;;
      /task\ *)
        TASK="${line#/task }"
        echo "(task=$TASK)"
        continue
        ;;
      /models\ *)
        MODELS_CSV="${line#/models }"
        echo "(models=$MODELS_CSV)"
        continue
        ;;
    esac

    panel_run "$line"
    echo
  done
}

main "$@"

