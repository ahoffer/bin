#!/usr/bin/env bash
set -euo pipefail

# ollama-panel.sh
# Multi-model panel using Ollama /api/chat:
#   generator -> verifier(s) -> reconciler
#
# Designed for concise, correct work across:
# Java 17, OSGi/Karaf, Spring, Solr, Docker, K8s, GitLab CI,
# ActiveMQ, Codice/DDF, Codice/Alliance, Postgres, TypeScript/React.

source "$(dirname "$0")/ollamalib" || exit 1

# Comma-separated models.
# First = generator, middle = verifier(s), last = reconciler.
MODELS_CSV="${OLLAMA_MODELS:-qwen2.5-coder:14b,qwen2.5-coder:7b,llama3.2:latest}"

TASK="${OLLAMA_TASK:-review}"   # review | create | debug
MODE="${OLLAMA_MODE:-quick}"   # quick | detail
QUICK_MODEL="${OLLAMA_QUICK_MODEL:-qwen2.5-coder:14b}"
DEBUG="${OLLAMA_DEBUG:-false}"

dbg() { [[ "$DEBUG" == "true" ]] && echo "$*" >&2 || true; }

NUM_PREDICT="${OLLAMA_NUM_PREDICT:-220}"
TEMP_GEN="${OLLAMA_TEMPERATURE_GEN:-0.2}"
TEMP_VERIFY="${OLLAMA_TEMPERATURE_VERIFY:-0.1}"
TEMP_RECONCILE="${OLLAMA_TEMPERATURE_RECONCILE:-0.2}"
TOP_P="${OLLAMA_TOP_P:-0.9}"
REPEAT_PENALTY="${OLLAMA_REPEAT_PENALTY:-1.1}"

STOP_SEQS=(
  $'\n\nUser:'
  $'\n\nHuman:'
  $'\n\nQ:'
  '</final>'
)

DOMAIN_CONTEXT=$'Primary stack / constraints:
- Java 17, Maven, JUnit 5
- OSGi + Apache Karaf (features, bundles, resolver issues, version ranges)
- Spring (Boot 2/3), including non-Boot OSGi containers
- Solr (schema, analysis, queries, performance)
- Docker (multi-stage builds, runtime issues)
- Kubernetes (deployments, Helm), config/secret hygiene
- GitLab CI/CD (.gitlab-ci.yml), runners, caching, artifacts, pipelines, deployments
- ActiveMQ (classic), DLQ patterns
- Codice/DDF, Codice/Alliance conventions
- Postgres (SQL, indexing, jsonb, migrations)
- TypeScript + React + Next.js + Tailwind

Output rules:
- Absolute minimum words. No preamble, no disclaimers, no offers to help further.
- Answer the question directly. If the answer is a single fact, give that fact and stop.
- Never say "as of my last update" or suggest the user check a website.
- Ask at most ONE clarifying question if required, otherwise assume and proceed.
- If code/config is requested, output code only.
'

SYSTEM_GEN=$'You are the generator.
Produce the best possible answer for the user request.
Keep it concise and actionable.
If critical version or environment details are missing, ask ONE question and stop.\n\n'"$DOMAIN_CONTEXT"

SYSTEM_VERIFY=$'You are a verifier.
Critique the generator output for correctness, omissions, and bad assumptions.
Propose concrete fixes.
Bullet points only.
Ask ONE question only if validation is impossible without environment/version info.\n\n'"$DOMAIN_CONTEXT"

SYSTEM_RECONCILE=$'You are the reconciler.
Merge generator output and verifier feedback into ONE final answer.
Prioritize correctness and brevity.
Include fixes.
Ask ONE question only if unavoidable.\n\n'"$DOMAIN_CONTEXT"

# If the message references a file path, read and embed its contents.
# Recognizes patterns like "review the file ~/path" or "review ~/path" or
# "debug the file /absolute/path". Expands ~ and caps at 200KB.
embed_file_content() {
  local msg="$1"
  local path=""

  # Match file path after common verbs
  if [[ "$msg" =~ (review|debug|explain|analyze|create)[[:space:]]+(the[[:space:]]+file[[:space:]]+)?([~/][^[:space:]]+) ]]; then
    path="${BASH_REMATCH[3]}"
  fi

  if [[ -z "$path" ]]; then
    printf '%s' "$msg"
    return
  fi

  # Expand leading ~
  path="${path/#\~/$HOME}"

  if [[ ! -f "$path" ]]; then
    printf '%s\n\n(File not found on this host: %s)' "$msg" "$path"
    return
  fi

  local max_bytes=200000
  local actual_bytes
  actual_bytes="$(wc -c < "$path" | tr -d ' ')"
  local content
  if (( actual_bytes > max_bytes )); then
    content="$(head -c "$max_bytes" "$path")"
    printf '%s\n\n--- FILE: %s (truncated to %d bytes) ---\n%s\n--- END FILE ---' \
      "$msg" "$path" "$max_bytes" "$content"
  else
    content="$(cat "$path")"
    printf '%s\n\n--- FILE: %s ---\n%s\n--- END FILE ---' \
      "$msg" "$path" "$content"
  fi
}

# Simple heuristic to detect queries that would benefit from web search.
# False positives add a few seconds of latency. False negatives just skip
# the search, same as current behavior.
needs_web_search() {
  local msg="${1,,}"  # lowercase for matching
  local pattern
  pattern='(what year|what month|what date|current |today|right now|latest |newest |recent )'
  pattern+='|(who is |what is the |how much |how many |price of |cost of |version of )'
  pattern+='|(search for |look up |google )'
  [[ "$msg" =~ $pattern ]]
}

# Fetch web search results via ddgr. Returns empty string on failure so the
# pipeline still works without search results.
web_search() {
  local query="$1"
  local search_results
  search_results=$(ddgr --json --num 5 "$query" 2>/dev/null \
    | jq -r '.[] | "Title: \(.title)\nURL: \(.url)\nSnippet: \(.abstract)\n"' 2>/dev/null) || true
  printf '%s' "${search_results:-}"
}

split_models() {
  local -a models
  IFS=',' read -ra models <<< "$MODELS_CSV"
  # Trim whitespace from each entry
  local trimmed=()
  for m in "${models[@]}"; do
    m="${m#"${m%%[![:space:]]*}"}"
    m="${m%"${m##*[![:space:]]}"}"
    [[ -n "$m" ]] && trimmed+=("$m")
  done
  if [[ ${#trimmed[@]} -lt 2 ]]; then
    echo "Need at least 2 models (generator, reconciler)." >&2
    return 1
  fi
  printf '%s\n' "${trimmed[@]}"
}

_build_chat_options() {
  local temperature="$1"
  local stop_json
  stop_json=$(jq -n '$ARGS.positional' --args -- "${STOP_SEQS[@]}")
  jq -n --argjson np "$NUM_PREDICT" --argjson temp "$temperature" \
    --argjson tp "$TOP_P" --argjson rp "$REPEAT_PENALTY" \
    --argjson stop "$stop_json" \
    '{num_predict:$np, temperature:$temp, top_p:$tp, repeat_penalty:$rp, stop:$stop}'
}

print_opts() {
  echo "HOST=$OLLAMA_HOST"
  echo "MODELS=$MODELS_CSV"
  echo "QUICK_MODEL=$QUICK_MODEL"
  echo "MODE=$MODE"
  echo "TASK=$TASK"
  echo "NUM_PREDICT=$NUM_PREDICT"
  echo "TEMP_GEN=$TEMP_GEN  TEMP_VERIFY=$TEMP_VERIFY  TEMP_RECONCILE=$TEMP_RECONCILE"
}

SYSTEM_QUICK=$'Answer the user request directly.\n\n'"$DOMAIN_CONTEXT"

quick_run() {
  local user_msg="$1"
  local force_search="${2:-auto}"
  local embedded
  embedded="$(embed_file_content "$user_msg")"

  local do_search=false
  case "$force_search" in
    yes) do_search=true ;;
    no)  do_search=false ;;
    *)   needs_web_search "$user_msg" && do_search=true ;;
  esac

  if $do_search; then
    dbg "[web search]"
    local search_results
    search_results="$(web_search "$user_msg")"
    if [[ -n "$search_results" ]]; then
      embedded=$'--- WEB SEARCH RESULTS ---\n'"$search_results"$'--- END WEB SEARCH ---\n\n'"$embedded"
    fi
  fi

  local opts
  opts=$(_build_chat_options "$TEMP_GEN")
  dbg "[quick: $QUICK_MODEL]"
  printf '%s' "$(ollama_chat_simple "$QUICK_MODEL" "$SYSTEM_QUICK" "[TASK=$TASK]"$'\n'"$embedded" "odev" "$opts")"
}

detail_run() {
  local user_msg="$1"
  local force_search="${2:-auto}"  # auto, yes, no
  local embedded
  embedded="$(embed_file_content "$user_msg")"

  # Web search injection
  local do_search=false
  case "$force_search" in
    yes) do_search=true ;;
    no)  do_search=false ;;
    *)   needs_web_search "$user_msg" && do_search=true ;;
  esac

  if $do_search; then
    dbg "[web search]"
    local search_results
    search_results="$(web_search "$user_msg")"
    if [[ -n "$search_results" ]]; then
      embedded=$'--- WEB SEARCH RESULTS ---\n'"$search_results"$'--- END WEB SEARCH ---\n\n'"$embedded"
    fi
  fi

  local models_output
  models_output=$(split_models)
  mapfile -t MODELS <<< "$models_output"
  local GEN="${MODELS[0]}"
  local REC="${MODELS[-1]}"
  local VERIFIERS=("${MODELS[@]:1:${#MODELS[@]}-2}")

  local gen_out ver_outs reconcile_in final_out

  local gen_opts ver_opts rec_opts
  gen_opts=$(_build_chat_options "$TEMP_GEN")
  ver_opts=$(_build_chat_options "$TEMP_VERIFY")
  rec_opts=$(_build_chat_options "$TEMP_RECONCILE")

  dbg "[generator: $GEN]"
  gen_out="$(ollama_chat_simple "$GEN" "$SYSTEM_GEN" "[TASK=$TASK]"$'\n'"$embedded" "odev" "$gen_opts")"

  ver_outs=""
  for v in "${VERIFIERS[@]}"; do
    dbg "[verifier: $v]"
    local vo
    vo="$(ollama_chat_simple "$v" "$SYSTEM_VERIFY" "USER REQUEST:"$'\n'"$embedded"$'\n\n'"GENERATOR ANSWER:"$'\n'"$gen_out" "odev" "$ver_opts")"
    ver_outs+=$'\n\n'"[VERIFIER: $v]"$'\n'"$vo"
  done

  reconcile_in="USER REQUEST:
$embedded

GENERATOR:
$gen_out
$ver_outs"

  dbg "[reconciler: $REC]"
  final_out="$(ollama_chat_simple "$REC" "$SYSTEM_RECONCILE" "$reconcile_in" "odev" "$rec_opts")"

  printf '%s' "$final_out"
}

# Dispatch to quick_run or detail_run with a timer
timed_run() {
  local start=$SECONDS
  if [[ "$MODE" == "detail" ]]; then
    detail_run "$@"
  else
    quick_run "$@"
  fi
  local elapsed=$(( SECONDS - start ))
  local mins=$(( elapsed / 60 ))
  local secs=$(( elapsed % 60 ))
  if (( mins > 0 )); then
    printf ' (%dm %ds)\n' "$mins" "$secs"
  else
    printf ' (%ds)\n' "$secs"
  fi
}

main() {
  dbg "Ollama multi-model panel"
  dbg "Models: $MODELS_CSV"
  dbg "Commands: /task review|create|debug | /models a,b,c | /web | /noweb | /opts | /quit"
  dbg ""

  while true; do
    IFS= read -e -r -p "> " line || break
    [[ -z "$line" ]] && continue
    history -s "$line"

    case "$line" in
      /quit) exit 0 ;;
      /opts) print_opts; continue ;;
      /task\ *)
        TASK="${line#/task }"
        echo "(task=$TASK)"
        continue
        ;;
      /models\ *)
        MODELS_CSV="${line#/models }"
        echo "(models=$MODELS_CSV)"
        continue
        ;;
      /web\ *)
        timed_run "${line#/web }" "yes"
        continue
        ;;
      /noweb\ *)
        timed_run "${line#/noweb }" "no"
        continue
        ;;
      /quick)
        MODE="quick"
        echo "(mode=quick)"
        continue
        ;;
      /detail)
        MODE="detail"
        echo "(mode=detail)"
        continue
        ;;
      /detail\ *)
        local saved_mode="$MODE"
        MODE=detail
        timed_run "${line#/detail }"
        MODE="$saved_mode"
        continue
        ;;
    esac

    timed_run "$line"
  done
}

main "$@"

