#!/usr/bin/env bash
set -euo pipefail

# Take all the certs that are trusted by the OS and add them to the NSSDB to let browsers use them.

# Check if certutil is available
if ! command -v certutil >/dev/null 2>&1; then
    echo "Error: certutil is not installed. Please install libnss3-tools package."
    exit 1
fi

DB="$HOME/.pki/nssdb"
DBDIR=$(dirname "$DB")

# 1) Ensure NSS DB exists & is initialized
if [ ! -f "$DB/cert9.db" ]; then
  echo "-> Initializing NSS DB at $DB..."
  mkdir -p "$DBDIR"
  certutil -d sql:"$DB" -N --empty-password
else
  echo "OK: NSS DB already exists at $DB"
fi

echo
echo "-> Importing all OS-trusted CAs from /etc/ssl/certs into NSS DB..."

# Check if /etc/ssl/certs directory exists
if [ ! -d "/etc/ssl/certs" ]; then
    echo "Error: /etc/ssl/certs directory not found"
    exit 1
fi

# 2) Loop over every hash symlink in /etc/ssl/certs
for link in /etc/ssl/certs/*.0; do
  # Skip if no files match the pattern
  [ -e "$link" ] || continue
  
  # Resolve the real certificate file
  certfile=$(readlink -f "$link")
  [ -f "$certfile" ] || continue

  # Validate that the file is actually a certificate
  if ! openssl x509 -in "$certfile" -text -noout >/dev/null 2>&1; then
    echo "Warning: Skipping invalid certificate file: $certfile"
    continue
  fi

  # Derive a nickname from the filename (strip extension)
  nick=$(basename "$certfile" | sed 's/\.[^.]*$//')

  # 3) Skip if already imported
  if certutil -d sql:"$DB" -L -n "$nick" &>/dev/null; then
    echo "OK: $nick already trusted"
    continue
  fi

  # 4) Import with full trust (CT=Certificate Trust, C=Client, C=Server)
  # Trust flags: CT,C,C = Certificate Trust, Client, Server
  echo "-> Importing $nick"
  if certutil -d sql:"$DB" \
         -A -n "$nick" \
         -t "CT,C,C" \
         -i "$certfile"; then
    echo "OK: Successfully imported $nick"
  else
    echo "Warning: Failed to import $nick"
  fi
done

echo
echo "SUCCESS: All OS CAs are now registered in NSS DB at $DB."

