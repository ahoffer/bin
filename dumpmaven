#!/bin/bash
set -euo pipefail

# Validate environment variables
if [[ -z "${RUNSHIFT_HOST:-}" ]] || [[ -z "${RUNSHIFT_PROJECT_ID:-}" ]] || [[ -z "${RUNSHIFT_TOKEN:-}" ]]; then
  echo "Error: Missing required environment variables" >&2
  echo "Required: RUNSHIFT_HOST, RUNSHIFT_PROJECT_ID, RUNSHIFT_TOKEN" >&2
  exit 1
fi

API_BASE="https://${RUNSHIFT_HOST}/api/v4"
PROJECT_ID="${RUNSHIFT_PROJECT_ID}"
TOKEN="${RUNSHIFT_TOKEN}"
MAX_PARALLEL_JOBS=30

# Function to make authenticated API calls
api_call() {
  local endpoint="$1"
  curl -sf -H "PRIVATE-TOKEN: ${TOKEN}" "${API_BASE}${endpoint}"
}

echo "Querying GitLab Package Registry..." >&2
echo >&2

# Get all Maven packages with pagination
page=1
all_packages="[]"

while true; do
  packages=$(api_call "/projects/${PROJECT_ID}/packages?package_type=maven&per_page=100&page=${page}&order_by=name&sort=asc")

  # Break if no packages returned
  if [[ $(echo "$packages" | jq '. | length') -eq 0 ]]; then
    break
  fi

  # Append to all_packages
  all_packages=$(echo "$all_packages" "$packages" | jq -s '.[0] + .[1]')
  ((page++))
done

# Count packages
package_count=$(echo "$all_packages" | jq '. | length')

if [[ $package_count -eq 0 ]]; then
  echo "No Maven artifacts found in the repository." >&2
  exit 0
fi

echo "Found ${package_count} Maven package(s)" >&2
echo >&2

# Print header
printf "%-35s %-30s %-20s %-15s %-10s %-10s %-50s\n" "Group ID" "Artifact ID" "Version" "Package Type" "Classifier" "File ID" "Filename" >&2
echo "====================================================================================================================================================================================================" >&2

# Function to process a single package
process_package() {
  local package="$1"

  package_id=$(echo "$package" | jq -r '.id')
  package_name=$(echo "$package" | jq -r '.name')
  version=$(echo "$package" | jq -r '.version')

  # Extract group ID and artifact ID from package name (format: groupId/artifactId or just artifactId)
  if [[ "$package_name" =~ ^(.+)/([^/]+)$ ]]; then
    group_id="${BASH_REMATCH[1]}"
    artifact_id="${BASH_REMATCH[2]}"
  else
    group_id="N/A"
    artifact_id="$package_name"
  fi

  # Get package files
  files=$(api_call "/projects/${PROJECT_ID}/packages/${package_id}/package_files")

  # Process each file
  has_files=false
  while IFS= read -r file; do
    filename=$(echo "$file" | jq -r '.file_name')
    file_id=$(echo "$file" | jq -r '.id')

    # Skip metadata files
    if [[ "$filename" =~ \.(md5|sha1|sha256|sha512|asc)$ ]] || [[ "$filename" == "maven-metadata.xml" ]]; then
      continue
    fi

    # Parse extension (type)
    if [[ "$filename" =~ \.([^.]+)$ ]]; then
      file_type="${BASH_REMATCH[1]}"
    else
      file_type="N/A"
    fi

    # Parse classifier
    # Format: artifactId-version[-classifier].extension
    basename="${filename%.*}"
    prefix="${artifact_id}-${version}"

    if [[ "$basename" == "$prefix" ]]; then
      classifier="N/A"
    elif [[ "$basename" =~ ^${prefix}-(.+)$ ]]; then
      classifier="${BASH_REMATCH[1]}"
    else
      classifier="N/A"
    fi

    # Print artifact details directly to stdout
    printf "%-35s %-30s %-20s %-15s %-10s %-10s %-50s\n" "$group_id" "$artifact_id" "$version" "$file_type" "$classifier" "$file_id" "$filename"
    has_files=true
  done < <(echo "$files" | jq -c '.[]')

  # If no files printed, show package with N/A
  if [[ "$has_files" == "false" ]]; then
    printf "%-35s %-30s %-20s %-15s %-10s %-10s %-50s\n" "$group_id" "$artifact_id" "$version" "N/A" "N/A" "N/A" "N/A"
  fi
}

# Export necessary variables and functions for parallel execution
export -f process_package
export -f api_call
export API_BASE PROJECT_ID TOKEN

# Process packages in parallel
pids=()

while IFS= read -r package; do
  # Wait if we've hit the parallel job limit
  while [[ ${#pids[@]} -ge $MAX_PARALLEL_JOBS ]]; do
    for i in "${!pids[@]}"; do
      if ! kill -0 "${pids[$i]}" 2>/dev/null; then
        unset 'pids[$i]'
      fi
    done
    pids=("${pids[@]}") # Re-index array
    [[ ${#pids[@]} -ge $MAX_PARALLEL_JOBS ]] && sleep 0.1
  done

  # Start background job
  process_package "$package" &
  pids+=($!)
done < <(echo "$all_packages" | jq -c '.[]')

# Wait for all remaining jobs to complete
wait
