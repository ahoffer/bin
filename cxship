#!/bin/bash
set -uo pipefail  # no -e: continue on errors, report all at end

# Build and deploy components.
# Maven modules are built sequentially, then docker images are built in
# parallel. Each component is deployed as soon as its image is ready.
# Must be run from within a project directory (walks up to find pom.xml).
# App is auto-detected from the project root directory name.
#
# Usage: cxship [options] [component...]
#        cxship --all
#        cxship edge
#        cxship edge app graphql
#
# Options:
#   --all               Build and deploy all components
#   -r, --remote HOST   Target k3s node (default: bigfish)
#   -n, --namespace NS  Kubernetes namespace (default: auto from app)

source cxlib.sh
timer_start

usage() {
  sed -n '4,18p' "$0"
  echo -e "\nComponents: $(list_components)"
  exit 0
}

remote_host="bigfish"
namespace=""
build_all=""
declare -a components=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage ;;
    --all) build_all=1; shift ;;
    -r|--remote) remote_host="$2"; shift 2 ;;
    -n|--namespace) namespace="$2"; shift 2 ;;
    -*) echo "Unknown option: $1" >&2; exit 1 ;;
    *) components+=("$1"); shift ;;
  esac
done

require_project_root
acquire_lock "builddeploy"

app=$(cxconfig app)
[[ -z "$namespace" ]] && namespace=$(cxconfig namespace)

mapfile -t all_components < <(cxconfig components)

if [[ -n "$build_all" ]]; then
  components=("${all_components[@]}")
elif [[ ${#components[@]} -eq 0 ]]; then
  err_msg "Specify components or use --all"
  echo "Available: ${all_components[*]}" >&2
  exit 1
fi

for c in "${components[@]}"; do
  valid_component "$c" all_components || { err_msg "Unknown component '$c'"; exit 1; }
done

project_root=$(cxconfig root)

# Phase 1: Maven modules, sequential. Abort if any fails since docker
# builds depend on these artifacts.
build_maven_modules "$project_root" "${components[@]}" || {
  err_msg "Maven build failed, aborting"
  exit 1
}

# Phase 2: Docker build + deploy, parallel per component. Each subshell
# builds the docker image and then immediately deploys it. TTY mode is
# disabled so parallel output prints complete lines.
declare -a failures=()
declare -A pids=()

for component in "${components[@]}"; do
  (
    _IS_TTY=""
    docker_build "$project_root" "$component" || exit 1
    deploy_component "$component" "$remote_host" "$namespace" || exit 1
  ) &
  pids[$component]=$!
done

for component in "${components[@]}"; do
  wait "${pids[$component]}" || failures+=("$component")
done

echo
if [[ ${#failures[@]} -eq 0 ]]; then
  echo "Shipped $(IFS=', '; echo "${components[*]}") - $(timer_elapsed)"
else
  echo "Failed $(IFS=', '; echo "${failures[*]}") - $(timer_elapsed)"
  exit 1
fi
